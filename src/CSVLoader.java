import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.UnsupportedEncodingException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.List;

import au.com.bytecode.opencsv.CSVReader;

/**
 * Licensed to Creative Commons ShareAlike 4.0 International (CC BY-SA 4.0)
 * */

/**
 * This class is responsible for reading and writing CSV Data. The data
 * delivered for clustering is assumed to be in CSV Format and fulfill some
 * column name formats.
 * 
 * @author De Melo Borges
 */
public class CSVLoader {

	/**
	 * This method is called by STDBSCAN.java for loading the points to be
	 * clustered from a CSV File.
	 * 
	 * @param csvPath
	 *            - The path to the CSV File to be loaded
	 * @param kdtree
	 *            - The KD-Tree from STDBSCAN.java.
	 * @return An array list containing the STPoints loaded from CSV
	 * @throws FileNotFoundException
	 * @throws IOException
	 */
	public static ArrayList<STPoint> stInitializePoints(String csvPath)
			throws FileNotFoundException, IOException {
		ArrayList<STPoint> points = new ArrayList<STPoint>();
		CSVReader reader = new CSVReader(new FileReader(csvPath));
		int count = 0;
		String line[];
		int[] keyIndexex = new int[6];
		int pointIndex = 0;
		// attributeColumns = null;
		while ((line = reader.readNext()) != null) {
			if (count == 0) {
				int checked = 0;
				for (int i = 0; i < line.length; i++) {
					// System.out.println(i+" - "+line[i]);
					if (line[i].contains("summary")) {
						keyIndexex[0] = i;
						checked++;
					} else if (line[i].contains("bitly")
							|| line[i].contains("url")) {
						keyIndexex[1] = i;
						checked++;
					} else if (line[i].contains("created_at")) {
						keyIndexex[2] = i;
						checked++;
					} else if (line[i].contains("lat")) {
						keyIndexex[3] = i;
						checked++;
					} else if (line[i].contains("lng")) {
						keyIndexex[4] = i;
						checked++;
					} else if (line[i].contains("description")) {
						keyIndexex[5] = i;
						checked++;
					}
				}
				if (!(checked >= 5)) {
					System.out.println("Checked count: " + checked);
					System.out
							.println("The specified columns does not exist in the provided data set.");
					System.out
							.println("Please provide following 6 columns: summary,bitly,created_at,lat,lng,duplicate");
					// System.exit(1);
				}
				count++;
			} else {
				try {
					String desc = line[keyIndexex[0]];
					String url = null;
					try {
						url = line[keyIndexex[1]];
					} catch (Exception e) {
						// TODO: handle exception
						e.printStackTrace();
						System.out.println(keyIndexex[1]);
						for (String tt : line) {
							System.out.println(tt);
						}
					}
					Date created_at;
					created_at = extractDate(line[keyIndexex[2]]);
					double lat = Double.parseDouble(line[keyIndexex[3]]);
					double lng = Double.parseDouble(line[keyIndexex[4]]);
					boolean duplicate = extractDuplicate(line[keyIndexex[5]]);
					// String title = line[9];
					STPoint p = new STPoint(lat, lng, duplicate, created_at,
							pointIndex, desc, url);

					points.add(p);
					pointIndex++;
					count++;
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		}
		reader.close();
		return points;
	}

	/**
	 * This method export (writes) the clustering results as CSV. Two files are
	 * generated by this method: 1) pointsPath = Original Data (Pointss) with
	 * extra column containing cluster label 2) clustersPath = Cluster center
	 * coordinates and cluster size
	 * 
	 * 
	 * @param points
	 *            - the Clustering Result
	 * @param pointsFilePath
	 *            - (1) File Path to Write
	 * @param clusterFilePath
	 *            - (2) File Path to Write
	 * @throws FileNotFoundException
	 * @throws UnsupportedEncodingException
	 */
	public static void resultsToCsv(ArrayList<STPoint> points,
			String pointsFilePath, String clusterFilePath)
			throws FileNotFoundException, UnsupportedEncodingException {
		ArrayList<Cluster> clusters = generateClusters(points);
		PrintWriter writer = new PrintWriter(clusterFilePath, "UTF-8");
		writer.write(Cluster.CSV_Header());
		for (Cluster cluster : clusters) {
			if (cluster.clusterLabel > 0)
				writer.write(cluster.toCSV());
		}
		writer.close();

		writer = new PrintWriter(pointsFilePath, "UTF-8");
		writer.write(STPoint.CSV_Header());
		for (Cluster cluster : clusters) {
			for (STPoint point : cluster.points) {
				writer.write(point.toCSV());
			}
		}
		writer.close();
	}

	private static ArrayList<Cluster> generateClusters(ArrayList<STPoint> points) {
		HashMap<Integer, List<STPoint>> clusterTable = new HashMap<Integer, List<STPoint>>();
		ArrayList<Cluster> clusters = new ArrayList<Cluster>();
		for (STPoint p : points) {
			addPoint2Clustermap(clusterTable, p, p.clusterLabel);
		}

		for (Integer key : asSortedList(clusterTable.keySet())) {
			List<STPoint> list = clusterTable.get(key);
			Cluster cluster = new Cluster(list, key);
			clusters.add(cluster);
		}
		return clusters;
	}

	@SuppressWarnings("unchecked")
	private static void addPoint2Clustermap(
			@SuppressWarnings("rawtypes") HashMap multiMap, STPoint p,
			int clusterLabel) {
		List<STPoint> list;
		if (multiMap.containsKey(p.clusterLabel)) {
			list = (List<STPoint>) multiMap.get(p.clusterLabel);
			list.add(p);
		} else {
			list = new ArrayList<STPoint>();
			list.add(p);
			multiMap.put(p.clusterLabel, list);
		}
	}

	private static Date extractDate(String string) throws ParseException {
		SimpleDateFormat simpleDateFormat = new SimpleDateFormat(
				"yyyy-MM-dd HH:mm:ss");
		Date date = null;
		try {
			date = simpleDateFormat.parse(string);
		} catch (Exception e) {
			date = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:SSSX")
					.parse(string);
		}

		return date;
	}

	private static boolean extractDuplicate(String string) {
		return string.contains("Duplicate") || string.contains("duplicate");
	}

	public static <T extends Comparable<? super T>> List<T> asSortedList(
			Collection<T> c) {
		List<T> list = new ArrayList<T>(c);
		java.util.Collections.sort(list);
		return list;
	}

}
